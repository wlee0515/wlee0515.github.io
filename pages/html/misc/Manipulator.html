<html>
<head>
  <meta name="viewport" content="width=400" />
  <title>Path Fnding</title>
  <style>
    body {
       background-color : rgb(0,0,0);
       color:white;
    }

    #Robot_Control , #Camera_Control {
      display : inline-block;
      vertical-align:top;
      padding-left : 30px;
      padding-right : 30px;
      width : 350px;
    }

    #div_Canvas {
      float : left;
      width: 70%;
      max-width : 600px;
      min-width : 400px;

    }

    canvas {
      border: 1px solid blue;
    }

    input {
      width: 75px;
    }

    .collapseButton {
      height: 20px;
      width: 20px;
    }
  </style>
  <script type="text/javascript">

    // -------- utility --------------------------

    function normalizeSignAngle(iAngle) {
      while (iAngle > Math.PI) {
        iAngle -= 2 * Math.PI;
      }
      while (iAngle < -Math.PI) {
        iAngle += 2 * Math.PI;
      }

      return iAngle;
    }

    function Vector3D(iX, iY, iZ) {

      this.x = iX;
      this.y = iY;
      this.z = iZ;

      this.set = function (iVector) {

        this.x = iVector.x;
        this.y = iVector.y;
        this.z = iVector.z;

      }

      this.add = function (iVector) {

        var wTmp = new Vector3D(this.x, this.y, this.z);

        wTmp.x += iVector.x;
        wTmp.y += iVector.y;
        wTmp.z += iVector.z;

        return wTmp;
      }


      this.subtract = function (iVector) {

        var wTmp = new Vector3D(this.x, this.y, this.z);

        wTmp.x -= iVector.x;
        wTmp.y -= iVector.y;
        wTmp.z -= iVector.z;

        return wTmp;
      }

      this.scale = function (iScaler) {

        var wTmp = new Vector3D(this.x, this.y, this.z);

        wTmp.x *= iScaler;
        wTmp.y *= iScaler;
        wTmp.z *= iScaler;

        return wTmp;
      }

      this.dot = function (iVector) {

        return iVector.x * this.x + iVector.y * this.y + iVector.z * this.z;
      }

      this.cross = function (iVector) {

        var wX = this.y * iVector.z - this.z * iVector.y;
        var wY = this.z * iVector.x - this.x * iVector.z;
        var wZ = this.x * iVector.y - this.y * iVector.x;

        var wTmp = new Vector3D(wX, wY, wZ);

        return wTmp;
      }

      this.sqMag = function () {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      }

      this.magnitude = function () {

        return Math.sqrt(this.sqMag());
      }

      this.XYMag = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }

      this.XZMag = function () {
        return Math.sqrt(this.x * this.x + this.z * this.z);
      }

      this.YZMag = function () {
        return Math.sqrt(this.y * this.y + this.z * this.z);
      }

      this.unitVector = function () {

        var wMagnitude = this.magnitude();

        if (wMagnitude > 0.001) {
          return this.scale(1 / wMagnitude);
        }

        return new Vector3D(1.0, 0.0, 0.0);

      }

      this.azimuth = function () {

        return Math.atan2(this.y, this.x);
      }

      this.elevation = function () {

        return Math.atan2(this.z, this.XYMag());
      }


      this.sin = function (iVector) {

        var wThisMag = this.magnitude();
        var wVectorMag = iVector.magnitude();
        if ((0.0001 < wThisMag) && (0.0001 < wVectorMag)) {

          var wSine = this.cross(iVector).magnitude() / (wThisMag * wVectorMag);

          if (wSine > 1.0) wSine = 1.0;
          if (wSine < -1.0) wSine = -1.0;
          return wSine;
        }

        return 0.0;
      }

      this.cos = function (iVector) {

        var wThisMag = this.magnitude();
        var wVectorMag = iVector.magnitude();
        if ((0.0001 < wThisMag) && (0.0001 < wVectorMag)) {
          var wCosine = this.dot(iVector) / (wThisMag * wVectorMag);
          if (wCosine > 1.0) wCosine = 1.0;
          if (wCosine < -1.0) wCosine = -1.0;
          return wCosine;
        }

        return 1.0;
      }


      this.angleOffset = function (iVector) {

        return Math.acos(this.cos(iVector));
      }

      this.projection = function (iVector) {

        var wVector = iVector.unitVector();
        var wProjection = wVector.scale(this.dot(wVector));

        return wProjection;
      }

    }

    function Matrix3x3() {

      this.Matrix = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]];

      this.multiplyVector3D = function (iVector) {

        var wX = this.Matrix[0][0] * iVector.x + this.Matrix[0][1] * iVector.y + this.Matrix[0][2] * iVector.z;
        var wY = this.Matrix[1][0] * iVector.x + this.Matrix[1][1] * iVector.y + this.Matrix[1][2] * iVector.z;
        var wZ = this.Matrix[2][0] * iVector.x + this.Matrix[2][1] * iVector.y + this.Matrix[2][2] * iVector.z;

        var wTmp = new Vector3D(wX, wY, wZ);
        return wTmp;
      }

      this.multiplyMatrix3x3 = function (iMatrix) {

        var wNewMat = new Matrix3x3();

        for (var i = 0 ; i < 3; ++i) {
          for (var j = 0 ; j < 3; ++j) {
            wNewMat.Matrix[i][j] = 0;
            for (var k = 0; k < 3; ++k) {
              wNewMat.Matrix[i][j] += this.Matrix[i][k] * iMatrix.Matrix[k][j];
            }
          }
        }

        return wNewMat;
      }

      this.getTranspose = function () {

        var wNewMat = new Matrix3x3();

        for (var i = 0 ; i < 3; ++i) {
          for (var j = 0 ; j < 3; ++j) {
            wNewMat.Matrix[i][j] = this.Matrix[j][i];
          }
        }

        return wNewMat;

      }

    }

    function EulerAngles(iRoll, iPitch, iYaw) {
      this.roll = iRoll;
      this.pitch = iPitch;
      this.yaw = iYaw;

      this.set = function (iRotationMatrix) {
        this.roll = iRotationMatrix.roll;
        this.pitch = iRotationMatrix.pitch;
        this.yaw = iRotationMatrix.yaw;
      }

      this.getMatrix = function () {

        var wC_Roll = Math.cos(this.roll);
        var wS_Roll = Math.sin(this.roll);

        var wRollMat = new Matrix3x3();
        wRollMat.Matrix = [[1.0, 0.0, 0.0], [0.0, wC_Roll, -wS_Roll], [0.0, wS_Roll, wC_Roll]];

        var wC_Pitch = Math.cos(this.pitch);
        var wS_Pitch = Math.sin(this.pitch);

        var wPitchMat = new Matrix3x3();
        wPitchMat.Matrix = [[wC_Pitch, 0.0, wS_Pitch], [0.0, 1.0, 0.0], [-wS_Pitch, 0.0, wC_Pitch]];

        var wC_Yaw = Math.cos(this.yaw);
        var wS_Yaw = Math.sin(this.yaw);

        var wYawMat = new Matrix3x3();
        wYawMat.Matrix = [[wC_Yaw, -wS_Yaw, 0.0], [wS_Yaw, wC_Yaw, 0.0], [0.0, 0.0, 1.0]];

        return wYawMat.multiplyMatrix3x3(wPitchMat.multiplyMatrix3x3(wRollMat));

      }

      this.rotateVector = function (iVector) {

        return this.getMatrix().multiplyVector3D(iVector);
      }

      this.rotateMatrix = function (iMatrix) {

        return this.getMatrix().multiplyMatrix3x3(iMatrix);
      }

      this.getInverse = function () {

        return this.getMatrix().getTranspose();
      }
    }

    function TransformationMatrix(iX, iY, iZ, iRoll, iPitch, iYaw) {

      this.useEulerAngles = true;
      this.rotation = new EulerAngles(iRoll, iPitch, iYaw);
      this.rotationMatrix = new Matrix3x3();

      this.translation = new Vector3D(iX, iY, iZ);

      this.getRotationMatrix = function () {

        if (true == this.useEulerAngles) {
          return this.rotation.getMatrix();
        }

        return this.rotationMatrix;
      }

      this.applyVector = function (iVector) {

        var wTmp = this.getRotationMatrix().multiplyVector3D(iVector);
        var wResult = wTmp.add(this.translation);

        return wResult;

      }

      this.applyInverseVector = function (iVector) {


        var wRotateInv = this.getRotationMatrix().getTranspose();

        var wTmp = iVector.subtract(this.translation);
        var wResult = wRotateInv.multiplyVector3D(wTmp);

        return wResult;
      }

      this.applyMatrix = function (iMatrix) {

        var wResult = this.getRotationMatrix().multiplyMatrix3x3(iMatrix);
        return wResult;

      }

      this.applyTransformationMatrix = function (iTransformationMatrix) {

        var wResult = new TransformationMatrix(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
        wResult.useEulerAngles = false;
        wResult.rotationMatrix = this.getRotationMatrix().multiplyMatrix3x3(iTransformationMatrix.getRotationMatrix());
        wResult.translation = this.applyVector(iTransformationMatrix.translation);

        return wResult;
      }


      this.getInverseMatrix = function (iTransformationMatrix) {

        var wResult = new TransformationMatrix(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
        wResult.useEulerAngles = false;
        wResult.rotationMatrix = this.getRotationMatrix().getTranspose();
        wResult.translation = wResult.rotationMatrix.multiplyVector3D(this.translation.scale(-1));

        return wResult;
      }

    }

    function RT_Matrix(iX, iY, iZ, iRoll, iPitch, iYaw) {

      this.useEulerAngles = true;
      this.rotation = new EulerAngles(iRoll, iPitch, iYaw);
      this.rotationMatrix = new Matrix3x3();

      this.translation = new Vector3D(iX, iY, iZ);

      this.applyVector = function (iVector) {

        var wResult = wTmp.add(this.translation);
        var wTmp = this.getRotationMatrix().multiplyVector3D(iVector);

        return wResult;

      }
    }

    function makePoint(iX, iY) {
      this.x = iX;
      this.y = iY;

    }

    // -------- Vector Objects -------------------

    function DrawCube(iWidth, iHeight, iDepth, iCenterX, iCenterY, iCenterZ) {

      var EdgeX1 = 0;
      var EdgeX2 = iWidth;

      if (true == iCenterX) {
        EdgeX1 -= iWidth / 2;
        EdgeX2 -= iWidth / 2;
      }


      var EdgeY1 = 0;
      var EdgeY2 = iHeight;

      if (true == iCenterY) {
        EdgeY1 -= iHeight / 2;
        EdgeY2 -= iHeight / 2;
      }

      var EdgeZ1 = 0;
      var EdgeZ2 = iDepth;

      if (true == iCenterZ) {
        EdgeZ1 -= iDepth / 2;
        EdgeZ2 -= iDepth / 2;
      }

      var v1 = new Vector3D(EdgeX1, EdgeY1, EdgeZ1);
      var v2 = new Vector3D(EdgeX2, EdgeY1, EdgeZ1);
      var v3 = new Vector3D(EdgeX2, EdgeY2, EdgeZ1);
      var v4 = new Vector3D(EdgeX1, EdgeY2, EdgeZ1);

      var v5 = new Vector3D(EdgeX1, EdgeY1, EdgeZ2);
      var v6 = new Vector3D(EdgeX2, EdgeY1, EdgeZ2);
      var v7 = new Vector3D(EdgeX2, EdgeY2, EdgeZ2);
      var v8 = new Vector3D(EdgeX1, EdgeY2, EdgeZ2);

      var wObj = new Array();
      wObj.push(v1); wObj.push(v2); wObj.push(v3); wObj.push(v4); wObj.push(v1);
      wObj.push(v5); wObj.push(v6); wObj.push(v7); wObj.push(v8); wObj.push(v5);

      wObj.push(v6); wObj.push(v2);
      wObj.push(v3); wObj.push(v7);
      wObj.push(v8); wObj.push(v4);

      return wObj;
    }

    function g3DObjectCategory() {
      this.eLine = 0;
      this.eCircle = 1;
    }

    function DrawAxis(iAxisLength) {

      var v1 = new Vector3D(0, 0, 0);
      var v2 = new Vector3D(iAxisLength, 0, 0);
      var v3 = new Vector3D(0, iAxisLength, 0);
      var v4 = new Vector3D(0, 0, iAxisLength);

      var wObj = new Array();
      wObj.push(v1); wObj.push(v2);
      wObj.push(v1); wObj.push(v3);
      wObj.push(v1); wObj.push(v4);
      wObj.push(v1);

      return wObj;
    }

    var g3DObjectIDCounter = 0;

    function g3DObject() {
      this.ObjectID = ++g3DObjectIDCounter;
      this.Color = "cyan";
      this.Category = "Line";
      this.VertexList = new Array();
      this.Radius = 20;

      this.SubObjList = new Array();

      this.Transformation = new TransformationMatrix(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);

      this.getObjectIDTransformation = function (iId, iInertialTransformationMatrix) {

        var wNewTransformation = null;
        if (null == iInertialTransformationMatrix) {
          wNewTransformation = this.Transformation;
        }
        else {
          wNewTransformation = iInertialTransformationMatrix.applyTransformationMatrix(this.Transformation);
        }

        if (iId == this.ObjectID) {
          return wNewTransformation;

        }

        if (0 < this.SubObjList.length) {

          for (var j = 0; j < this.SubObjList.length; ++j) {

            var wChildTransform = this.SubObjList[j].getObjectIDTransformation(iId, wNewTransformation);

            if (null != wChildTransform) {
              return wChildTransform;
            }
          }
        }

        return null;
      }


      this.plotOnCanvas = function (iCtx, iInertialTransformationMatrix) {

        var wNewTransformation = iInertialTransformationMatrix.applyTransformationMatrix(this.Transformation);
        iCtx.fillStyle = this.Color;
        iCtx.strokeStyle = this.Color;

        if ("Line" == this.Category) {
          if (this.VertexList.length > 1) {
            var wLastPoint = wNewTransformation.applyVector(this.VertexList[0]);

            for (var j = 1; j < this.VertexList.length; ++j) {
              var wNextPoint = wNewTransformation.applyVector(this.VertexList[j]);


              iCtx.beginPath();
              iCtx.moveTo(wLastPoint.y, -wLastPoint.z);
              iCtx.lineTo(wNextPoint.y, -wNextPoint.z);
              iCtx.stroke();

              wLastPoint = wNextPoint;
            }
          }
        }
        else if ("Sphere" == this.Category) {

          for (var j = 0; j < this.VertexList.length; ++j) {
            var wPoint = wNewTransformation.applyVector(this.VertexList[j]);

            iCtx.beginPath();
            iCtx.arc(wPoint.y, -wPoint.z, this.Radius, 0.0, 2 * Math.PI);
            iCtx.stroke();

          }
        }

        if (0 < this.SubObjList.length) {

          for (var j = 0; j < this.SubObjList.length; ++j) {
            this.SubObjList[j].plotOnCanvas(iCtx, wNewTransformation);
          }
        }
      }
    }

    function RobotSegment(iLength, iWidth) {
      this.g3DObject = new g3DObject();
      this.g3DObject.Transformation.translation.z = iLength;


      this.axis1 = new g3DObject();
      this.axis1.VertexList = DrawAxis(iLength / 4);
      this.axis1.Transformation.translation.z = -iLength;
      this.axis1.Color = "pink";
      this.g3DObject.SubObjList.push(this.axis1);

      this.box = new g3DObject();
      this.box.VertexList = DrawCube(iWidth, iWidth, iLength, true, true, false);
      this.box.Transformation.translation.z = -iLength;
      this.g3DObject.SubObjList.push(this.box);

      this.ball = new g3DObject();
      this.ball.VertexList.push(new Vector3D(0, 0, 0));
      this.ball.Category = "Sphere";
      this.ball.Radius = iWidth / 2;
      this.ball.Color = "lime";
      this.g3DObject.SubObjList.push(this.ball);

      this.cmdRoll = 0.0;
      this.cmdPitch = 0.0;
      this.cmdYaw = 0.0;

      this.axis2 = new g3DObject();
      this.axis2.VertexList = DrawAxis(iLength / 4);
      this.axis2.Transformation.translation.z = iLength;
      this.axis2.Color = "red";
      this.box.SubObjList.push(this.axis2);


      this.appendPart = function (iRobotSegment) {
        this.ball.SubObjList.push(iRobotSegment.g3DObject);
      }


      this.setRoll = function (iRoll) {
        this.ball.Transformation.rotation.roll = iRoll;
      }

      this.setPitch = function (iPitch) {
        this.ball.Transformation.rotation.pitch = iPitch;
      }

      this.setYaw = function (iYaw) {
        this.ball.Transformation.rotation.yaw = iYaw;
      }


      this.setCmdRoll = function (iRoll) {
        this.cmdRoll = iRoll;
      }

      this.setCmdPitch = function (iPitch) {
        this.cmdPitch = iPitch;
      }

      this.setCmdYaw = function (iYaw) {
        this.cmdYaw = iYaw;
      }


      this.getRoll = function () {
        return this.ball.Transformation.rotation.roll;
      }

      this.getPitch = function () {
        return this.ball.Transformation.rotation.pitch;
      }

      this.getYaw = function () {
        return this.ball.Transformation.rotation.yaw;
      }

      this.processTick = function (iDt) {

        var wRoll = this.getRoll();
        var wPitch = this.getPitch();
        var wYaw = this.getYaw();

        var wDRoll = this.cmdRoll - wRoll;
        var wDPitch = this.cmdPitch - wPitch;
        var wDYaw = this.cmdYaw - wYaw;

        var wTau = 1.5 * iDt;
        this.setRoll(wRoll + wTau * wDRoll);
        this.setPitch(wPitch + wTau * wDPitch);
        this.setYaw(wYaw + wTau * wDYaw);
      }

      this.getObjectID = function () {
        return this.ball.ObjectID;
      }
    }

    // -------- Program --------------------------

    var gCameraYaw = new TransformationMatrix(0.0, 0.0, 0.0, 0.0, 0.0, Math.PI / 4);
    var gCameraPitch = new TransformationMatrix(100.0, 0.0, -100.0, 0.0, Math.PI / 4, 0);
    var gCanvasObj = new g3DObject();
    var gScale = 1;

    var gControlMode = 0;

    var gBase = new RobotSegment(40, 50);
    var gSeg2 = new RobotSegment(100, 20);
    var gSeg3 = new RobotSegment(100, 15);
    var gSeg4 = new RobotSegment(50, 10);

    var gGripperPivot1 = new RobotSegment(0, 0);
    var gGripperBase1 = new RobotSegment(25, 10);
    var gGripperTip1 = new RobotSegment(25, 10);

    var gGripperPivot2 = new RobotSegment(0, 0);
    var gGripperBase2 = new RobotSegment(25, 10);
    var gGripperTip2 = new RobotSegment(25, 10);

    var gTargetBall = new g3DObject();
    var gTargetX = 100;
    var gTargetY = 100;
    var gTargetZ = 100;

    var gTargetRoll = 0.0;
    var gTargetElevation = 0.0;
    var gTargetAzimuth = 0.0;
    var gSolutionAngle = 0;

    var gTargetRoll_transition = 0.0;
    var gTargetElevation_transition = 0.0;
    var gTargetAzimuth_transition = 0.0;
    var gSolutionAngle_transition = 0;

    var gBone = new g3DObject();

    var gMouseHandler = {
      mouseIsDown: false,
      mouseDownLocation: new makePoint(0, 0),
      mouseRelativeNodeLocation: new makePoint(0, 0),
      selectedNode: -1,

      InitCameraRoll: 0.0,
      InitCameraPitch: 0.0,
      InitCameraYaw: 0.0
    }

    function init() {


      gGripperPivot1.appendPart(gGripperBase1);
      gGripperBase1.appendPart(gGripperTip1);
      gGripperPivot1.setCmdPitch(-Math.PI / 4);
      gGripperBase1.setCmdPitch(Math.PI / 3);


      gGripperPivot2.appendPart(gGripperBase2);
      gGripperBase2.appendPart(gGripperTip2);
      gGripperPivot2.setCmdPitch(Math.PI / 4);
      gGripperBase2.setCmdPitch(-Math.PI / 3);

      gBase.appendPart(gSeg2);
      gSeg2.appendPart(gSeg3);
      gSeg3.appendPart(gSeg4);
      gSeg4.appendPart(gGripperPivot1);
      gSeg4.appendPart(gGripperPivot2);

      gCanvasObj.SubObjList.push(gBase.g3DObject);

      gTargetBall = new g3DObject();
      gTargetBall.VertexList.push(new Vector3D(0, 0, 0));
      gTargetBall.Transformation.translation.x = 100;
      gTargetBall.Transformation.translation.y = 100;
      gTargetBall.Transformation.translation.z = 100;
      gTargetBall.Category = "Sphere";
      gTargetBall.Radius = 5;
      gTargetBall.Color = "red";



      axis1 = new g3DObject();
      axis1.VertexList = DrawAxis(20);
      axis1.Color = "pink";
      gTargetBall.SubObjList.push(axis1);

      gCanvasObj.SubObjList.push(gTargetBall);

      gBone.Color = "white";
      gBone.VertexList.push(new Vector3D(0, 0, 0));
      gBone.VertexList.push(new Vector3D(0, 0, 0));
      gBone.VertexList.push(new Vector3D(0, 0, 0));
      gBone.VertexList.push(new Vector3D(0, 0, 0));
      gBone.VertexList.push(new Vector3D(0, 0, 0));
      gCanvasObj.SubObjList.push(gBone);


      syncRobotInput();

      var wCanvas = document.getElementById("OuputCanvas");
      wCanvas.addEventListener("mousedown", canvasMouseDown, false);
      wCanvas.addEventListener("mousemove", canvasMouseMove, false);
      wCanvas.addEventListener("mouseup", canvasMouseUp, false);
      wCanvas.addEventListener("mouseout", canvasMouseUp, false);

      resize();


      setInterval(processTick, 100);
    }


    function resize() {
      var wCanvas = document.getElementById("OuputCanvas");
      var wSize = wCanvas.parentElement.clientWidth;
      //if (wSize > wCanvas.parentElement.clientHeight) wSize = wCanvas.parentElement.clientHeight;

      wCanvas.height = wSize - 2;
      wCanvas.width = wSize - 2;
    }

    function canvasMouseDown(iEvent) {

      if (null != iEvent) {

        var wCanvas = document.getElementById("OuputCanvas");

        x = iEvent.x - wCanvas.offsetLeft - document.body.scrollLeft;
        y = iEvent.y - wCanvas.offsetTop - document.body.scrollTop;


        if (false == gMouseHandler.mouseIsDown) {
          gMouseHandler.mouseIsDown = true;
          gMouseHandler.mouseDownLocation.x = x;
          gMouseHandler.mouseDownLocation.y = y;

          gMouseHandler.InitCameraRoll = gCameraPitch.rotation.roll;
          gMouseHandler.InitCameraPitch = gCameraPitch.rotation.pitch;
          gMouseHandler.InitCameraYaw = gCameraYaw.rotation.yaw;
        }
        else {
          gMouseHandler.mouseIsDown = false;
        }
      }

      canvasMouseMove(iEvent);
    }

    function canvasMouseUp(iEvent) {

      if (null != iEvent) {
          gMouseHandler.mouseIsDown = false;
      }

      canvasMouseMove(iEvent);
    }

    function canvasMouseMove(iEvent) {


      var wCanvas = document.getElementById("OuputCanvas");

      x = iEvent.x - wCanvas.offsetLeft - document.body.scrollLeft;
      y = iEvent.y - wCanvas.offsetTop - document.body.scrollTop;

      if (true == gMouseHandler.mouseIsDown) {

        gCameraPitch.rotation.roll = gMouseHandler.InitCameraRoll;
        gCameraPitch.rotation.pitch = gMouseHandler.InitCameraPitch + Math.atan2(y - gMouseHandler.mouseDownLocation.y, gCameraPitch.translation.x);
        gCameraYaw.rotation.yaw = gMouseHandler.InitCameraYaw + Math.atan2(x - gMouseHandler.mouseDownLocation.x, gCameraPitch.translation.x);

      }

    }

    function processTick() {

      var dTime = 0.1;
      gBase.processTick(dTime);
      gSeg2.processTick(dTime);
      gSeg3.processTick(dTime);
      gSeg4.processTick(dTime);

      gGripperPivot1.processTick(dTime);
      gGripperBase1.processTick(dTime);
      gGripperTip1.processTick(dTime);

      gGripperPivot2.processTick(dTime);
      gGripperBase2.processTick(dTime);
      gGripperTip2.processTick(dTime);

      gTargetBall.Transformation.translation.x += dTime * (gTargetX - gTargetBall.Transformation.translation.x);
      gTargetBall.Transformation.translation.y += dTime * (gTargetY - gTargetBall.Transformation.translation.y);
      gTargetBall.Transformation.translation.z += dTime * (gTargetZ - gTargetBall.Transformation.translation.z);


      gTargetRoll_transition += dTime * (gTargetRoll - gTargetRoll_transition);
      gTargetElevation_transition += dTime * (gTargetElevation - gTargetElevation_transition);
      gTargetAzimuth_transition += dTime * (gTargetAzimuth - gTargetAzimuth_transition);
      gSolutionAngle_transition += dTime * (gSolutionAngle - gSolutionAngle_transition);

      if (0 == gControlMode) {
        syncRobotInput(gControlMode);
      }
      else if (1 == gControlMode) {
        CommandGripperToTarget();
        syncRobotInput(gControlMode);
      }

      var wCanvas = document.getElementById("OuputCanvas");

      drawCanvas(wCanvas);

    }

    function CommandGripperToTarget() {

      var BaseTransformMat = gCanvasObj.getObjectIDTransformation(gBase.getObjectID());
      var Seg2TransformMat = gCanvasObj.getObjectIDTransformation(gSeg2.getObjectID());
      var Seg3TransformMat = gCanvasObj.getObjectIDTransformation(gSeg3.getObjectID());
      var Seg4TransformMat = gCanvasObj.getObjectIDTransformation(gSeg4.getObjectID());

      var GripperTip1TransformMat = gCanvasObj.getObjectIDTransformation(gGripperTip1.getObjectID());
      var GripperTip2TransformMat = gCanvasObj.getObjectIDTransformation(gGripperTip2.getObjectID());

      var BaseLocation = BaseTransformMat.translation
      var Seg2Location = Seg2TransformMat.translation
      var Seg3Location = Seg3TransformMat.translation
      var Seg4Location = Seg4TransformMat.translation
      var GripperTip1Location = GripperTip1TransformMat.translation
      var GripperTip2Location = GripperTip2TransformMat.translation

      var GripperTipLocation = GripperTip1Location.add(GripperTip2Location).scale(0.5);

      var EffectorLength = GripperTipLocation.subtract(Seg3Location).magnitude();
      var MidSectionLength = Seg3Location.subtract(Seg2Location).magnitude();
      var UpperSectionLength = Seg2Location.subtract(BaseLocation).magnitude();

      var wContactEuler = new EulerAngles(gTargetRoll_transition, gTargetElevation_transition, gTargetAzimuth_transition);

      var wTargetLocation = new Vector3D(0.0, 0.0, 0.0);
      wTargetLocation.set(gTargetBall.Transformation.translation);

      var wEffectorDirection = wContactEuler.rotateVector(new Vector3D(EffectorLength, 0.0, 0.0));
      var wEffectorBase = wTargetLocation.subtract(wEffectorDirection);
      var wEffectorUp = wContactEuler.rotateVector(new Vector3D(0.0, 0.0, 1.0));

      var wBaseToEffectorBase = wEffectorBase.subtract(BaseLocation);
      var wBaseToEffectorBaseMag = wBaseToEffectorBase.magnitude();
      // Law of Cosine
      var wMidPointAngleCosine = wBaseToEffectorBaseMag * wBaseToEffectorBaseMag - MidSectionLength * MidSectionLength - UpperSectionLength * UpperSectionLength;
      wMidPointAngleCosine /= -2 * MidSectionLength * UpperSectionLength;

      var wMidPointAngle = Math.PI;
      var wDeltaAngleEFfector = 0;
      var wDeltaAngleBase = 0;


      // assume that the Mid Section and the BaseSection forms a line
      var wStraightArmLength = MidSectionLength + UpperSectionLength;
      var wBaseToTarget = wTargetLocation.subtract(BaseLocation);
      var wBaseToTargetMag = wBaseToTarget.magnitude();

      // Law of Cosine
      var wEffectorBaseAngleCosine = wBaseToTargetMag * wBaseToTargetMag - wStraightArmLength * wStraightArmLength - EffectorLength * EffectorLength;
      wEffectorBaseAngleCosine /= -2 * wStraightArmLength * EffectorLength;


      var wMidPointLocation = new Vector3D(0.0, 0.0, 0.0);

      if (1.0 > Math.abs(wMidPointAngleCosine)) {
        // need to be less than one for solution

        wMidPointAngle = Math.acos(wMidPointAngleCosine);
        wDeltaAngleEFfector = Math.asin((Math.sin(wMidPointAngle) / wBaseToEffectorBaseMag) * UpperSectionLength);
        wDeltaAngleBase = Math.asin((Math.sin(wMidPointAngle) / wBaseToEffectorBaseMag) * MidSectionLength);

        var wMidPointPlaneX = wEffectorBase.subtract(BaseLocation).unitVector();
        var wMidPointPlaneY = wMidPointPlaneX.cross(wEffectorDirection).unitVector();
        var wMidPointPlaneZ = wMidPointPlaneX.cross(wMidPointPlaneY).unitVector();

        var wMidPointComponentX = wMidPointPlaneX.scale(UpperSectionLength * Math.cos(wDeltaAngleBase));
        var wMidPointComponentY = wMidPointPlaneY.scale(UpperSectionLength * Math.sin(wDeltaAngleBase) * Math.sin(gSolutionAngle_transition));
        var wMidPointComponentZ = wMidPointPlaneZ.scale(UpperSectionLength * Math.sin(wDeltaAngleBase) * Math.cos(gSolutionAngle_transition));

        var wMidPointOffsetFromBase = wMidPointComponentX.add(wMidPointComponentY.add(wMidPointComponentZ));
        wMidPointLocation = BaseLocation.add(wMidPointOffsetFromBase);

      }
      else {
        // The target Location is too far


        if (1.0 > Math.abs(wEffectorBaseAngleCosine)) {
          var wNewEffectorBaseLocation =

          wEffectorBasePointAngle = Math.acos(wEffectorBaseAngleCosine);
          wDeltaAngleTarget = Math.asin((Math.sin(wEffectorBasePointAngle) / wBaseToTargetMag) * wStraightArmLength);
          wDeltaAngleBase = Math.asin((Math.sin(wEffectorBasePointAngle) / wBaseToTargetMag) * EffectorLength);

          var wEffectorBasePointPlaneX = wBaseToTarget.unitVector();
          var wEffectorBasePointPlaneY = wBaseToTarget.cross(wEffectorDirection).unitVector();
          var wEffectorBasePointPlaneZ = wEffectorBasePointPlaneX.cross(wEffectorBasePointPlaneY).unitVector();

          var wEffectorBaseX = wEffectorBasePointPlaneX.scale(wStraightArmLength * Math.cos(wDeltaAngleBase));
          var wEffectorBaseZ = wEffectorBasePointPlaneZ.scale(wStraightArmLength * Math.sin(wDeltaAngleBase));

          var wEffectorBaseOffsetFromBase = wEffectorBaseX.add(wEffectorBaseZ);
          wEffectorBase.set(BaseLocation.add(wEffectorBaseOffsetFromBase));

          var wMidPointX = wEffectorBasePointPlaneX.scale(UpperSectionLength * Math.cos(wDeltaAngleBase));
          var wMidPointZ = wEffectorBasePointPlaneZ.scale(UpperSectionLength * Math.sin(wDeltaAngleBase));


          var wMidPointOffsetFromBase = wMidPointX.add(wMidPointZ);
          wMidPointLocation = BaseLocation.add(wMidPointOffsetFromBase);


        }
        else {
          // Target is too far with compensated result.
        }

      }

      gBone.VertexList[0].set(BaseLocation);
      gBone.VertexList[1].set(wMidPointLocation);
      gBone.VertexList[2].set(wEffectorBase);
      gBone.VertexList[3].set(wTargetLocation);
      gBone.VertexList[4].set(wTargetLocation.add(wEffectorUp));

      if (1.0 > Math.abs(wMidPointAngleCosine)) {
        gBone.Color = "white";
      }
      else {
        gBone.Color = "red";

      }
      //-------- Setting points in Robot -----------

      if (1.0 > Math.abs(wMidPointAngleCosine)) {
        var wBaseToMidZ = wMidPointLocation.subtract(BaseLocation);
        var wMidToEndZ = wEffectorBase.subtract(wMidPointLocation);
        var wEndToTargetZ = wTargetLocation.subtract(wEffectorBase);

        var wTargetX = wEffectorUp;

        var wBasToMedY = new Vector3D(0.0, 0.0, 1.0).cross(wBaseToMidZ).unitVector();
        var wMidToEndY = wBaseToMidZ.cross(wMidToEndZ).unitVector();
        var wEndToTgtY = wMidToEndZ.cross(wEndToTargetZ).unitVector();

        var wBasToMedX = wBasToMedY.cross(wBaseToMidZ).unitVector();
        var wMidToEndX = wMidToEndY.cross(wMidToEndZ).unitVector();
        var wEndToTgtX = wEndToTgtY.cross(wEndToTargetZ).unitVector();

        var FlipSolution = false;

        // ----- Base Component Input -------------------
        wYaw_Base = wBaseToMidZ.azimuth();
        wPitch_Base = new Vector3D(0.0, 0.0, 1.0).angleOffset(wBaseToMidZ);


        if (Math.PI / 2 < Math.abs(wYaw_Base)) {
          if (wYaw_Base > 0) {
            wYaw_Base -= Math.PI;
          }
          else {
            wYaw_Base += Math.PI;
          }

          wPitch_Base *= -1;
          FlipSolution = true;
        }

        gBase.setCmdRoll(0.0);
        gBase.setCmdYaw(wYaw_Base);
        gBase.setCmdPitch(wPitch_Base);


        // ----- Mid Component Input -------------------

        var wMidToEndProg = wMidToEndZ.projection(wBaseToMidZ);
        var wMidToEndPlanar = wMidToEndZ.subtract(wMidToEndProg);

        var wCross_Mid = wBasToMedX.cross(wMidToEndPlanar);
        var wDot_Mid = wCross_Mid.dot(wBaseToMidZ);

        var wYaw_Mid = wBasToMedX.angleOffset(wMidToEndPlanar);

        if (wDot_Mid < 0) {
          wYaw_Mid *= -1;
        }

        if (true == FlipSolution) {
          if (wYaw_Mid > 0) {
            wYaw_Mid -= Math.PI;
          }
          else {
            wYaw_Mid += Math.PI;
          }
          FlipSolution = !FlipSolution;
        }

        var wPitch_Mid = wMidToEndZ.angleOffset(wBaseToMidZ);

        if (Math.PI / 2 < Math.abs(wYaw_Mid)) {
          if (wYaw_Mid > 0) {
            wYaw_Mid -= Math.PI;
          }
          else {
            wYaw_Mid += Math.PI;
          }

          wPitch_Mid *= -1;
          FlipSolution = !FlipSolution;
        }

        gSeg2.setCmdRoll(0.0);
        gSeg2.setCmdYaw(wYaw_Mid);
        gSeg2.setCmdPitch(wPitch_Mid);

        // ----- End Component Input -------------------

        var wEndToTgtProg = wEndToTargetZ.projection(wMidToEndZ);
        var wEndToTgtPlanar = wEndToTargetZ.subtract(wEndToTgtProg);

        var wCross_End = wMidToEndX.cross(wEndToTgtPlanar);
        var wDot_End = wCross_End.dot(wMidToEndZ);

        var wYaw_End = wMidToEndX.angleOffset(wEndToTgtPlanar);

        if (wDot_End < 0) {
          wYaw_End *= -1;
        }

        if (true == FlipSolution) {
          if (wYaw_End > 0) {
            wYaw_End -= Math.PI;
          }
          else {
            wYaw_End += Math.PI;
          }
          FlipSolution = !FlipSolution;
        }

        var wPitch_End = wEndToTargetZ.angleOffset(wMidToEndZ);

        if (Math.PI / 2 < Math.abs(wYaw_End)) {
          if (wYaw_End > 0) {
            wYaw_End -= Math.PI;
          }
          else {
            wYaw_End += Math.PI;
          }

          wPitch_End *= -1;
          FlipSolution = !FlipSolution;
        }

        gSeg3.setCmdRoll(0.0);
        gSeg3.setCmdYaw(wYaw_End);
        gSeg3.setCmdPitch(wPitch_End);

        // ------------ Tip Rotation ------------------------
        var wTgtProg = wTargetX.projection(wEndToTargetZ);
        var wTgtUpPlanar = wTargetX.subtract(wTgtProg);

        var wCross_Tip = wEndToTgtX.cross(wTgtUpPlanar);
        var wDot_Tip = wCross_Tip.dot(wEndToTargetZ);

        var wYaw_Tip = wTargetX.angleOffset(wTgtUpPlanar);

        if (wDot_Tip < 0) {
          wYaw_Tip *= -1;
        }

        if (true == FlipSolution) {
          if (wYaw_Tip > 0) {
            wYaw_Tip -= Math.PI;
          }
          else {
            wYaw_Tip += Math.PI;
          }
          FlipSolution = !FlipSolution;
        }

        gSeg4.setCmdRoll(0.0);
        gSeg4.setCmdYaw(wYaw_Tip);
      }
      else if (1.0 > Math.abs(wEffectorBaseAngleCosine)) {

        var wBaseToEndBaseZ = wEffectorBase.subtract(BaseLocation);
        var wEndToTargetZ = wTargetLocation.subtract(wEffectorBase);

        var wBasToEndBaseY = new Vector3D(0.0, 0.0, 1.0).cross(wBaseToEndBaseZ).unitVector();
        var wEndToTgtY = wBaseToEndBaseZ.cross(wEndToTargetZ).unitVector();

        var wBasToEndBaseX = wBasToEndBaseY.cross(wBaseToEndBaseZ).unitVector();
        var wEndToTgtX = wEndToTgtY.cross(wEndToTargetZ).unitVector();

        var wTargetX = wEffectorUp;

        var FlipSolution = false;

        // ----- Base Component Input -------------------
        wYaw_Base = wBaseToEndBaseZ.azimuth();
        wPitch_Base = new Vector3D(0.0, 0.0, 1.0).angleOffset(wBaseToEndBaseZ);


        if (Math.PI / 2 < Math.abs(wYaw_Base)) {
          if (wYaw_Base > 0) {
            wYaw_Base -= Math.PI;
          }
          else {
            wYaw_Base += Math.PI;
          }

          wPitch_Base *= -1;
          FlipSolution = true;
        }

        gBase.setCmdRoll(0.0);
        gBase.setCmdYaw(wYaw_Base);
        gBase.setCmdPitch(wPitch_Base);

        // ---------End Component Input -------

        var wEndToTgtProg = wEndToTargetZ.projection(wBaseToEndBaseZ);
        var wEndToTgtPlanar = wEndToTargetZ.subtract(wEndToTgtProg);

        var wCross_End = wBasToEndBaseX.cross(wEndToTgtPlanar);
        var wDot_End = wCross_End.dot(wBaseToEndBaseZ);

        var wYaw_End = wBasToEndBaseX.angleOffset(wEndToTgtPlanar);

        if (wDot_End < 0) {
          wYaw_End *= -1;
        }

        if (true == FlipSolution) {
          if (wYaw_End > 0) {
            wYaw_End -= Math.PI;
          }
          else {
            wYaw_End += Math.PI;
          }
          FlipSolution = !FlipSolution;
        }

        var wPitch_End = wEndToTargetZ.angleOffset(wBaseToEndBaseZ);

        if (Math.PI / 2 < Math.abs(wYaw_End)) {
          if (wYaw_End > 0) {
            wYaw_End -= Math.PI;
          }
          else {
            wYaw_End += Math.PI;
          }

          wPitch_End *= -1;
          FlipSolution = !FlipSolution;
        }


        gSeg2.setCmdRoll(0.0);
        gSeg2.setCmdYaw(wYaw_End / 2);
        gSeg2.setCmdPitch(0.0);

        gSeg3.setCmdRoll(0.0);
        gSeg3.setCmdYaw(wYaw_End / 2);
        gSeg3.setCmdPitch(wPitch_End);

        // ------------ Tip Rotation ------------------------

        var wTgtProg = wTargetX.projection(wEndToTargetZ);
        var wTgtUpPlanar = wTargetX.subtract(wTgtProg);

        var wCross_Tip = wEndToTgtX.cross(wTgtUpPlanar);
        var wDot_Tip = wCross_Tip.dot(wEndToTargetZ);

        var wYaw_Tip = wTargetX.angleOffset(wTgtUpPlanar);

        if (wDot_Tip < 0) {
          wYaw_Tip *= -1;
        }

        if (true == FlipSolution) {
          if (wYaw_Tip > 0) {
            wYaw_Tip -= Math.PI;
          }
          else {
            wYaw_Tip += Math.PI;
          }
          FlipSolution = !FlipSolution;
        }

        gSeg4.setCmdRoll(0.0);
        gSeg4.setCmdYaw(wYaw_Tip);
      }
    }

    function drawCanvas(iCanvas) {


      var wCtx = iCanvas.getContext("2d");
      var wCanvasHeight = iCanvas.height;
      var wCanvasWidth = iCanvas.width;

      wCtx.clearRect(0, 0, wCanvasWidth, wCanvasHeight);

      wCtx.translate(wCanvasWidth / 2, wCanvasHeight / 2);
      wCtx.scale(gScale, gScale);

      gCanvasObj.plotOnCanvas(wCtx, gCameraPitch.applyTransformationMatrix(gCameraYaw));

      wCtx.scale(1 / gScale, 1 / gScale);

      wCtx.translate(-wCanvasWidth / 2, -wCanvasHeight / 2);



    }

    function syncRobotInput(iMode) {

      if (0 == iMode) {
        { var wDOM = document.getElementById("base_roll"); if (null != wDOM) gBase.cmdRoll = wDOM.value * (Math.PI / 180); }
        { var wDOM = document.getElementById("base_pitch"); if (null != wDOM) gBase.cmdPitch = wDOM.value * (Math.PI / 180); }
        { var wDOM = document.getElementById("base_yaw"); if (null != wDOM) gBase.cmdYaw = wDOM.value * (Math.PI / 180); }
        { var wDOM = document.getElementById("seg2_roll"); if (null != wDOM) gSeg2.cmdRoll = wDOM.value * (Math.PI / 180); }
        { var wDOM = document.getElementById("seg2_pitch"); if (null != wDOM) gSeg2.cmdPitch = wDOM.value * (Math.PI / 180); }
        { var wDOM = document.getElementById("seg2_yaw"); if (null != wDOM) gSeg2.cmdYaw = wDOM.value * (Math.PI / 180); }
        { var wDOM = document.getElementById("seg3_roll"); if (null != wDOM) gSeg3.cmdRoll = wDOM.value * (Math.PI / 180); }
        { var wDOM = document.getElementById("seg3_pitch"); if (null != wDOM) gSeg3.cmdPitch = wDOM.value * (Math.PI / 180); }
        { var wDOM = document.getElementById("seg3_yaw"); if (null != wDOM) gSeg3.cmdYaw = wDOM.value * (Math.PI / 180); }
        { var wDOM = document.getElementById("seg4_roll"); if (null != wDOM) gSeg4.cmdRoll = wDOM.value * (Math.PI / 180); }
        { var wDOM = document.getElementById("seg4_pitch"); if (null != wDOM) gSeg4.cmdPitch = wDOM.value * (Math.PI / 180); }
        { var wDOM = document.getElementById("seg4_yaw"); if (null != wDOM) gSeg4.cmdYaw = wDOM.value ^ (Math.PI / 180); }

        { var wDOM = document.getElementById("JointControlForm"); if (null != wDOM) wDOM.style.display = "initial"; }
        { var wDOM = document.getElementById("TargetControlForm"); if (null != wDOM) wDOM.style.display = "none"; }

      }
      else if (1 == iMode) {
        { var wDOM = document.getElementById("base_roll"); if (null != wDOM) wDOM.value = gBase.cmdRoll * (180 / Math.PI); }
        { var wDOM = document.getElementById("base_pitch"); if (null != wDOM) wDOM.value = gBase.cmdPitch * (180 / Math.PI); }
        { var wDOM = document.getElementById("base_yaw"); if (null != wDOM) wDOM.value = gBase.cmdYaw * (180 / Math.PI); }
        { var wDOM = document.getElementById("seg2_roll"); if (null != wDOM) wDOM.value = gSeg2.cmdRoll * (180 / Math.PI); }
        { var wDOM = document.getElementById("seg2_pitch"); if (null != wDOM) wDOM.value = gSeg2.cmdPitch * (180 / Math.PI); }
        { var wDOM = document.getElementById("seg2_yaw"); if (null != wDOM) wDOM.value = gSeg2.cmdYaw * (180 / Math.PI); }
        { var wDOM = document.getElementById("seg3_roll"); if (null != wDOM) wDOM.value = gSeg3.cmdRoll * (180 / Math.PI); }
        { var wDOM = document.getElementById("seg3_pitch"); if (null != wDOM) wDOM.value = gSeg3.cmdPitch * (180 / Math.PI); }
        { var wDOM = document.getElementById("seg3_yaw"); if (null != wDOM) wDOM.value = gSeg3.cmdYaw * (180 / Math.PI); }
        { var wDOM = document.getElementById("seg4_roll"); if (null != wDOM) wDOM.value = gSeg4.cmdRoll * (180 / Math.PI); }
        { var wDOM = document.getElementById("seg4_pitch"); if (null != wDOM) wDOM.value = gSeg4.cmdPitch * (180 / Math.PI); }
        { var wDOM = document.getElementById("seg4_yaw"); if (null != wDOM) wDOM.value = gSeg4.cmdYaw * (180 / Math.PI); }

        { var wDOM = document.getElementById("JointControlForm"); if (null != wDOM) wDOM.style.display = "none"; }
        { var wDOM = document.getElementById("TargetControlForm"); if (null != wDOM) wDOM.style.display = "initial"; }

      }


      { var wDOM = document.getElementById("ball_x"); if (null != wDOM) gTargetX = wDOM.value; }
      { var wDOM = document.getElementById("ball_y"); if (null != wDOM) gTargetY = wDOM.value; }
      { var wDOM = document.getElementById("ball_z"); if (null != wDOM) gTargetZ = wDOM.value; }
      { var wDOM = document.getElementById('ball_r'); if (null != wDOM) gTargetRoll = wDOM.value * (Math.PI / 180); }
      { var wDOM = document.getElementById('ball_p'); if (null != wDOM) gTargetElevation = wDOM.value * (Math.PI / 180); }
      { var wDOM = document.getElementById('ball_q'); if (null != wDOM) gTargetAzimuth = wDOM.value * (Math.PI / 180); }
      { var wDOM = document.getElementById('ball_a'); if (null != wDOM) gSolutionAngle = wDOM.value * (Math.PI / 180); }

    }


    function camera_conntrol(iType) {

      switch (iType) {
        case "P_L":
          gCameraYaw.translation.y += 25;
          break;
        case "P_R":
          gCameraYaw.translation.y -= 25;
          break;
        case "P_U":
          gCameraYaw.translation.z += 25;
          break;
        case "P_D":
          gCameraYaw.translation.z -= 25;
          break;

        case "R_L":
          gCameraYaw.rotation.yaw += 15 * Math.PI / 180;
          break;
        case "R_R":
          gCameraYaw.rotation.yaw -= 15 * Math.PI / 180;
          break;
        case "R_U":
          gCameraPitch.rotation.pitch += 15 * Math.PI / 180;
          break;
        case "R_D":
          gCameraPitch.rotation.pitch -= 15 * Math.PI / 180;

        case "Z_I":
          gScale += 0.1;
          break;
        case "Z_O":
          gScale -= 0.1;
          if (gScale < 0.1) gScale = 0.1;
          break;
      }
    }

    function controlMethodSelection(iValue, iSelected) {

      if (true == iSelected) {
        switch (iValue) {
          case "JointMode":
            gControlMode = 0;

            break;
          case "TargetMode":
            gControlMode = 1;

            break;
        }
      }
    }

    function collapseDiv(iDivId, iButton) {

      var wButton = document.getElementById(iButton);

      if (null != wButton) {
        var iDivId = document.getElementById(iDivId);

        if (null != iDivId) {

          if ("-" == wButton.value) {
            iDivId.style.display = "none";
            wButton.value = "+";
          }
          else if ("+" == wButton.value) {
            iDivId.style.display = "initial";
            wButton.value = "-";
          }
        }
      }

    }


  </script>
</head>
<body onload="init()" onresize="resize()">
  <div id="Program_Body">
    <div id="div_Canvas">
      <canvas id="OuputCanvas"></canvas>
    </div>
    <!--div id="div_Control"-->
      <div id="Camera_Control">
        <h3>
          <input type="button" value="-" class="collapseButton" onclick="collapseDiv('CameraControlForm', this.id)" id="CameraControlFormButton" />
          Camera Control
        </h3>
        <div id="CameraControlForm">

          <h4>Pan</h4>
          <input type="button" value="Up" onclick="camera_conntrol('P_U')" />
          <input type="button" value="Down" onclick="camera_conntrol('P_D')" />
          <br />
          <input type="button" value="Left" onclick="camera_conntrol('P_L')" />
          <input type="button" value="Right" onclick="camera_conntrol('P_R')" />
          <br />
          <h4>Rotate</h4>
          <input type="button" value="Up" onclick="camera_conntrol('R_U')" />
          <input type="button" value="Down" onclick="camera_conntrol('R_D')" />
          <br />
          <input type="button" value="Left" onclick="camera_conntrol('R_L')" />
          <input type="button" value="Right" onclick="camera_conntrol('R_R')" />
          <br />
          <h4>Zoom</h4>
          <input type="button" value="Zoom In" onclick="camera_conntrol('Z_I')" />
          <input type="button" value="Zoom Out" onclick="camera_conntrol('Z_O')" />
          <br />
        </div>
      </div>
      <div id="Robot_Control">
        <h3>
          <input type="button" value="-" class="collapseButton" onclick="collapseDiv('RobotControlForm', this.id)" id="RobotControlFormButton" />
          Robot Control
        </h3>

        <div id="RobotControlForm">
          <input type="radio" name="Control_Method_ID" value="Joint_Control" checked="1" onchange="controlMethodSelection('JointMode', this.checked)">Joint Control
          <br />
          <input type="radio" name="Control_Method_ID" value="Target_Control" onchange="controlMethodSelection('TargetMode', this.checked)">Target Control
          <br />
          <div id="JointControlForm">
            <h4>Base Segment</h4>
            Roll:  <input type="number" min="-180" max="180" step="10" value="0" id="base_roll" />
            Pitch: <input type="number" min="-180" max="180" step="10" value="0" id="base_pitch" />
            Yaw:   <input type="number" min="-180" max="180" step="10" value="0" id="base_yaw" />
            <br />
            <h4>Second Segment</h4>
            Roll:  <input type="number" min="-180" max="180" step="10" value="0" id="seg2_roll" />
            Pitch: <input type="number" min="-180" max="180" step="10" value="0" id="seg2_pitch" />
            Yaw:   <input type="number" min="-180" max="180" step="10" value="0" id="seg2_yaw" />
            <br />
            <h4>Third Segment</h4>
            Roll:  <input type="number" min="-180" max="180" step="10" value="0" id="seg3_roll" />
            Pitch: <input type="number" min="-180" max="180" step="10" value="0" id="seg3_pitch" />
            Yaw:   <input type="number" min="-180" max="180" step="10" value="0" id="seg3_yaw" />
            <br />
            <h4>End Effector</h4>
            Roll:  <input type="number" min="-180" max="180" step="10" value="0" id="seg4_roll" />
            Pitch: <input type="number" min="-180" max="180" step="10" value="0" id="seg4_pitch" />
            Yaw:   <input type="number" min="-180" max="180" step="10" value="0" id="seg4_yaw" />
            <br />

          </div>
          <div id="TargetControlForm">

            <h4>Target Location</h4>
            X:<input type="number" min="-1000" max="1000" step="10" value="100" id="ball_x" />
            Y:<input type="number" min="-1000" max="1000" step="10" value="100" id="ball_y" />
            Z:<input type="number" min="-1000" max="1000" step="10" value="100" id="ball_z" />

            <br />


            <h4>Intercept Euler Angle</h4>
            Roll:  <input type="number" min="-180" max="180" step="10" value="0" id="ball_r" />
            Pitch: <input type="number" min="-180" max="180" step="10" value="0" id="ball_p" />
            Yaw:   <input type="number" min="-180" max="180" step="10" value="0" id="ball_q" />

            <br />

            <h4>Arm Solution Angle</h4>
            Alpha: <input type="number" min="-180" max="180" step="10" value="0" id="ball_a" />


          </div>
        </div>
      </div>
    <!--/div-->
  </div>
</body>
</html>

