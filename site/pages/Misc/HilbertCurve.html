<HTML>
<HEAD>
<META NAME="GENERATOR" Content="Microsoft Visual Studio">
<TITLE>Hilbert Curve Test</TITLE>
  <script>

    var gGlobal = {
      InputOrderId : "id_InputOrder",
      OutputCanvasId : "id_OutputGraphCanvas",
    }
    
    // Color Conversion
    var colorMapping = {
      color: function (iR, iG, iB, iAlpha) {
        
        return {
          r: iR,
          g: iG,
          b: iB,
          a: iAlpha
        };
      },

      getColorString : function (iColor) {
        return 'rgba(' + iColor.r + ',' + iColor.g + ','+  iColor.b + ','+ iColor.a + ')';
      },

      mapValueToColorScale: function (iRatio) {

        var wRatio = iRatio;

        if (wRatio > 1) {
          wRatio = 1;
        }
        else if (wRatio < 0) {
          wRatio = 0;
        }

        wColorIndex = Math.floor(wRatio * 1785 + 0.5);
        if (wColorIndex <= 255) {
          return this.color(wColorIndex, 0, 0, 255);
        }
        if (wColorIndex <= 2 * 255) {
          return this.color(255, wColorIndex - 255, 0, 255);
        }
        if (wColorIndex <= 3 * 255) {
          return this.color(3 * 255 - wColorIndex, 255, 0, 255);
        }
        if (wColorIndex <= 4 * 255) {
          return this.color(0, 255, wColorIndex - 3 * 255, 255);
        }
        if (wColorIndex <= 5 * 255) {
          return this.color(0, 5 * 255 - wColorIndex, 255, 255);
        }
        if (wColorIndex <= 6 * 255) {
          return this.color(wColorIndex - 5 * 255, 0, 255, 255);
        }
        if (wColorIndex <= 7 * 255) {
          return this.color(255, wColorIndex - 6 * 255, 255, 255);
        }

        return this.color(255, 255, 255, 255);
      },


      mapColorScaleToValue: function (iRGB, iValueMax, iValueMin) {
        wColorIndex = 0
        if ((iRGB.g == 0) && (iRGB.b == 0)) {
          wColorIndex = iRGB.r;
        }
        else if ((iRGB.r == 255) && (iRGB.b == 0)) {
          wColorIndex = iRGB.g + 255;
        }
        else if ((iRGB.g == 255) && (iRGB.b == 0)) {
          wColorIndex = 3 * 255 - iRGB.r;
        }
        else if ((iRGB.r == 0) && (iRGB.g == 255)) {
          wColorIndex = iRGB.b + 3 * 255;
        }
        else if ((iRGB.r == 0) && (iRGB.b == 255)) {
          wColorIndex = 5 * 255 - iRGB.g;
        }
        else if ((iRGB.g == 0) && (iRGB.b == 255)) {
          wColorIndex = iRGB.r + 5 * 255;
        }
        else if ((iRGB.r == 255) && (iRGB.b == 255)) {
          wColorIndex = iRGB.g + 6 * 255;
        }

        return parseInt((wColorIndex / 1785) * (iValueMax - iValueMin) + iValueMin + 0.5);

      },


      mapValueToBinaryColorRGB: function (iValue) {
        wNewValue = iValue + 32768;
        wR = parseInt(wNewValue % 255);
        wTemp = parseInt(wNewValue / 255);
        wG = parseInt(wTemp % 255);
        wB = parseInt(wTemp / 255);
        return this.color(wR, wG, wB, 255);
      },

      mapBinaryColorRGBToValue: function (iRGB) {
        return iRGB.b * 255 * 255 + iRGB.g * 255 + iRGB.r - 32768
      }
    }

    function updateCurveData() {
      var wInputOrderDom = document.getElementById(gGlobal.InputOrderId);
      if (null == wInputOrderDom) {
        alert("Unable to find Input Order for Curve");
        return;
      }
      
      var wOutputCanvasDom = document.getElementById(gGlobal.OutputCanvasId);
      if (null == wOutputCanvasDom) {
        alert("Unable to find Output Canvas for Curve");
        return;
      }

      var wCurveOrder = parseInt(wInputOrderDom.value);
      
      var wCurveMap = computeCurveMap(wCurveOrder);
      var iCtx = wOutputCanvasDom.getContext('2d');

      iCtx.clearRect(0,0,500,500);
      plotCurveMap(wCurveMap, iCtx, 0, 0, 500, 500);
    }

    function computeCurveMap(iOrder) {
      var wNumberOfDataPerAxis =  Math.pow(2, iOrder);
      var wNumberOfData =  wNumberOfDataPerAxis*wNumberOfDataPerAxis;
      var wDtoX =  new Int32Array(wNumberOfData);
      var wDtoY =  new Int32Array(wNumberOfData);
      var wXYToD =  new Int32Array(wNumberOfData);
      
      for (var wi = 0; wi < wNumberOfData; ++wi) {
        var wXY = d2xy(wNumberOfDataPerAxis, wi);
        wDtoX[wi] = wXY.x;
        wDtoY[wi] = wXY.y;
        
        var wIndex = wXY.y* wNumberOfDataPerAxis + wXY.x;
        if (wIndex < wNumberOfData);
        wXYToD[wIndex] = wi;
      }

      var wCurveMap = {
        Order : iOrder,
        NumberOfDataPerAxis : wNumberOfDataPerAxis,
        NumberOfData : wNumberOfData,
        DtoX : wDtoX,
        DtoY : wDtoY,
        XYToD : wXYToD,
      };

      return wCurveMap;
    }
    
    function plotCurveMap(iCurveMap, iCanvasContext, iXStart, iYStart, iWidth, iHeight) {
      var wCellCount = iCurveMap.NumberOfDataPerAxis;
      var wWidthDelta = iWidth/(wCellCount);
      var wHeightDelta = iHeight/(wCellCount);
      var wXStart = iXStart + 0.5*wWidthDelta;
      var wYStart = iYStart + 0.5*wHeightDelta;
      
      for (var wi = 0; wi < iCurveMap.NumberOfData - 1; ++wi) {
        var wXLineStart = iCurveMap.DtoX[wi]*wWidthDelta + wXStart;
        var wYLineStart = iCurveMap.DtoY[wi]*wHeightDelta + wYStart;
        var wXLocation = iCurveMap.DtoX[wi+1]*wWidthDelta + wXStart;
        var wYLocation = iCurveMap.DtoY[wi+1]*wHeightDelta + wYStart;
      
        var wColor = colorMapping.mapValueToColorScale(wi/iCurveMap.NumberOfData);
        iCanvasContext.strokeStyle = colorMapping.getColorString(wColor);
        iCanvasContext.beginPath();
        iCanvasContext.moveTo(wXLineStart, wYLineStart);
        iCanvasContext.lineTo(wXLocation, wYLocation);
        iCanvasContext.stroke();        
      }
    }

    function computeNewCurve() {
      for (var i = 0; i < wDataSize; ++i) {
        var wData = document.getElementById("Data" + i);
        if (null != wData) {
          wCurveDataArray[i] = wData.value - 1;
          if (wCurveDataArray[i] >= wDataSize) {
            wCurveDataArray[i] = wDataSize - 1;
          }
          if (wCurveDataArray[i] < 0) {
            wCurveDataArray[i] = 0;
          }

          wData.value = wCurveDataArray[i] + 1;
        }
      }
      var wCurveOrder = document.getElementById("ModOrder");
      var numberOfData = 4;

      if (null != wCurveOrder) {
        var Vallue = wCurveOrder.value;
        numberOfData = Math.pow(2, Math.floor(wCurveOrder.value));
        numberOfData *= numberOfData;
      }
      wModDataSize = numberOfData;

      for (var i = 0; i < wModDataSize; ++i) {
        if(i >= wModCurveDataArray.length) {
          wModCurveDataArray.push(0);
        }

        wModCurveDataArray[i] = -1;
      }


      var wIndexScale = ((wDataSize -1) / (wModDataSize - 1));
      var wAccumulator = 0;
      var wOldIndex = 0;
      var wNewIndex = -1;
      var wCounter = 0;
      for (var i = 0; i < wDataSize; ++i) {
        wNewIndex = Math.floor(((1/wIndexScale) * i) + 0.5);

        if(wNewIndex != wOldIndex)
        {
          wModCurveDataArray[wOldIndex] = wAccumulator / wCounter;
          wCounter = 0;
          wAccumulator = 0;
        }

        wAccumulator += Math.floor(((1 / wIndexScale) * wCurveDataArray[i]) + 0.5);
        wCounter += 1;
        wOldIndex = wNewIndex;
      }

      wModCurveDataArray[wOldIndex] = wAccumulator / wCounter;

      var strine = "";
      for (var i = 1; i < wModDataSize-1; ++i) {
        
        if (-1 == wModCurveDataArray[i]) {
        
          
          var j = 0;
          for ( j = i; j < wModDataSize && wModCurveDataArray[j] == -1 ; ++j) {
          }

          var upper = j;

          for (j = i; j != 0 && wModCurveDataArray[j] == -1 ; --j) {
          }

          var lower = j;

          wModCurveDataArray[i] = ((wModCurveDataArray[upper] - wModCurveDataArray[lower]) / (upper - lower)) * (i - lower) + wModCurveDataArray[lower];
          wModCurveDataArray[i] = Math.floor(wModCurveDataArray[i] + 0.5);

      //    alert(wModCurveDataArray[i] + " = " + upper + "," + lower + "," +  i)

        }

        strine += "," + wModCurveDataArray[i];
      }

    //  alert(strine);
      for (var i = 0; i < wModDataSize; ++i) {
        if (wModCurveDataArray[i] >= wModDataSize) {
          wModCurveDataArray[i] = wModDataSize - 1;
        }
        if (wModCurveDataArray[i] < 0) {
          wModCurveDataArray[i] = 0;
        }
      }

      plot();

      
      var strign = "";
      for (var i = 0; i < 8; ++i) {
        for (var j = 0; j < 8; ++j) {
          strign += "," +  xy2d(8, i, j);
        }
        
        strign += "\n";
      }
      alert(strign);
    }

    function plot()
    {
      plotLine();
      plotGraph();

    }

    function plotLine()
    {
      var canvas = document.getElementById('LineCanvas');
      var context = canvas.getContext('2d');

      context.setTransform(1, 0, 0, 1, 0, 0);
      context.clearRect(0, 0, canvas.width, canvas.height);
      
      context.strokeStyle = "lightgreen";
      DrawGridLines(context, 0, 0, canvas.width, canvas.height, wDataSize - 1, wDataSize - 1);
      context.stroke();

      context.strokeStyle = "lightblue";
      DrawGridLines(context, 0, 0, canvas.width, canvas.height, wModDataSize - 1, wModDataSize - 1);
      context.stroke();

      var wOriginalLineData = new Array(wDataSize);

      for (var i = 0; i < wDataSize; ++i) {
        wOriginalLineData[i] = new Array(2);
        wOriginalLineData[i][0] = i;
        wOriginalLineData[i][1] = wCurveDataArray[i];
      }

      context.strokeStyle = "darkgreen";
      DrawLineData(context, 0, 0, canvas.width / (wDataSize - 1), canvas.height / (wDataSize - 1), wOriginalLineData);
      context.stroke();

      var wModLineData = new Array(wModDataSize);

      for (var i = 0; i < wModDataSize; ++i) {
        wModLineData[i] = new Array(2);
        wModLineData[i][0] = i;
        wModLineData[i][1] = wModCurveDataArray[i];
      }


      context.strokeStyle = "darkblue";
      DrawLineData(context, 0, 0, canvas.width / (wModDataSize - 1), canvas.height / (wModDataSize - 1), wModLineData);
      context.stroke();
    }

    function plotGraph()
    { 
      var canvas = document.getElementById('GraphCanvas');
      var context = canvas.getContext('2d');

      context.setTransform(1, 0, 0, 1, 0, 0);
      context.clearRect(0, 0, canvas.width, canvas.height);

      context.strokeStyle = "lightgreen";
      DrawGridLines(context, 0, 0, canvas.width, canvas.height, Math.sqrt(wDataSize), Math.sqrt(wDataSize));
      context.stroke();

      context.strokeStyle = "lightblue";
      DrawGridLines(context, 0, 0, canvas.width, canvas.height, Math.sqrt(wModDataSize), Math.sqrt(wModDataSize));
      context.stroke();


      var wOriginalLineData = new Array(wDataSize);

      context.strokeStyle = "darkgreen";

      var wString = "";
      for (var i = 0; i < wDataSize; ++i) {
        wOriginalLineData[i] = new Array(2);
        var wXYCo0 = d2xy(Math.sqrt(wDataSize), i);
        wOriginalLineData[i][0] = wXYCo0.x;
        wOriginalLineData[i][1] = wXYCo0.y;

        if (1 <= wCurveDataArray[i]) {
          var wXYCo1 = d2xy(Math.sqrt(wDataSize), wCurveDataArray[i]);

          var wLineData = [[wXYCo0.x, wXYCo0.y], [wXYCo1.x, wXYCo1.y]];
          DrawLineData(context, canvas.width / Math.sqrt(wDataSize) / 2, canvas.height / Math.sqrt(wDataSize) / 2, canvas.width / Math.sqrt(wDataSize), canvas.height / Math.sqrt(wDataSize), wLineData);
          context.stroke();
        }
      }

      DrawLineData(context, canvas.width / Math.sqrt(wDataSize) / 2, canvas.height / Math.sqrt(wDataSize) / 2, canvas.width / Math.sqrt(wDataSize), canvas.height / Math.sqrt(wDataSize), wOriginalLineData);
      context.stroke();


      context.strokeStyle = "darkblue";

      var wModLineData = new Array(wModDataSize);

      for (var i = 0; i < wModDataSize; ++i) {
        wModLineData[i] = new Array(2);
        var wXYCo0 = d2xy(Math.sqrt(wModDataSize), i);
        wModLineData[i][0] = wXYCo0.x;
        wModLineData[i][1] = wXYCo0.y;

        if (1 <= wModCurveDataArray[i]) {
          var wXYCo1 = d2xy(Math.sqrt(wModDataSize), wModCurveDataArray[i]);

          var wLineData = [[wXYCo0.x, wXYCo0.y], [wXYCo1.x, wXYCo1.y]];
          DrawLineData(context, canvas.width / Math.sqrt(wModDataSize) / 2, canvas.height / Math.sqrt(wModDataSize) / 2, canvas.width / Math.sqrt(wModDataSize), canvas.height / Math.sqrt(wModDataSize), wLineData);
          context.stroke();
        }
      }

      DrawLineData(context, canvas.width / Math.sqrt(wModDataSize)/2, canvas.height / Math.sqrt(wModDataSize) / 2, canvas.width / Math.sqrt(wModDataSize), canvas.height / Math.sqrt(wModDataSize), wModLineData);
      context.stroke();
    }
    /*
    //convert (x,y) to d
    int xy2d (int n, int x, int y) {
    int rx, ry, s, d=0;
    for (s=n/2; s>0; s/=2) {
      rx = (x & s) > 0;
      ry = (y & s) > 0;
      d += s * s * ((3 * rx) ^ ry);
      rot(s, &x, &y, rx, ry);
    }
    return d;
    }
    */
    function xy2d(iSize, iX, iY)
    {
      var wRx, wRy, wS, wd = 0, wX = iX,wY = iY;

      for(var wS = Math.floor(iSize /2); wS > 0; wS = Math.floor(wS/2)  )
      {
        if (Math.abs(wX) % (2 * wS) >= wS) {
          wRx = 1;
        }
        else {
          wRx = 0;
        }

        if (Math.abs(wY) % (2 * wS) >= (wS - 1)) {
          wRy = 1;
        }
        else {
          wRy = 0;
        }

        wd += wS * wS * Math.abs(3 * wRx - wRy);

        var wRot = rot(wS, wX, wY, wRx, wRy);
        wX = wRot.x;
        wY = wRot.y;
      }
      return wd;
    }
    /*
    //convert d to (x,y)
    void d2xy(int n, int d, int *x, int *y) {
      int rx, ry, s, t=d;
      *x = *y = 0;
      for (s=1; s<n; s*=2) {
        rx = 1 & (t/2);
        ry = 1 & (t ^ rx);
        rot(s, x, y, rx, ry);
        *x += s * rx;
        *y += s * ry;
        t /= 4;
      }
    }
    */
    function d2xy (iSize, iD)
    {
      var wRx, wRy, wT = iD, wX =0; wY = 0;

      for(var wS = 1; wS < iSize; wS*= 2)
      {
        wRx = 0;
        if ((Math.floor(wT / 2) % 2) == 1)
        {
          wRx = 1;
        }

        wRy = 0;

        if ((wT % 2) != wRx) {
          wRy = 1;
        }

        var wRot = rot(wS, wX, wY, wRx, wRy);

        wX = wRot.x + wRx*wS;
        wY = wRot.y + wRy*wS;
        wT = Math.floor(wT/4);
        }

      return {
      x : wX,
      y : wY
    }

    }
    /*
    //rotate/flip a quadrant appropriately
    void rot(int n, int *x, int *y, int rx, int ry) {
      if (ry == 0) {
        if (rx == 1) {
          *x = n-1 - *x;
          *y = n-1 - *y;
        }

        //Swap x and y
        int t  = *x;
        *x = *y;
        *y = t;
      }
    }
    */
    function rot(iSize, iX, iY, iRx, iRy)
    {
      var wx = iX, wy = iY;

      if(iRy == 0)
      {
        if(iRx == 1)
        {
          wx = iSize - 1 - wx;
          wy = iSize - 1 - wy;
        }

        var t = wx;
        wx = wy;
        wy = t;
      }

      return {
        x : wx,
        y : wy
      }
    }

    function Init() {
      updateCurveData();
    }

  </script>
</HEAD>
<BODY onload="Init()">
  <div id="CurveDisplay">
    <canvas id="id_OutputGraphCanvas" width="500" height="500" style="border:1px solid #000000;"></canvas>
  </div>
  <div name ="CurveOrderControl">
    <input type="number" id="id_InputOrder" min="1" max="10" value="1" onchange="updateCurveData()">
    <div id="id_OutputText"></div>
  </div>
</BODY>
</HTML>
